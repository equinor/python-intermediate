# Function and class decorators

Go through the decorator concept.


## Exercises

1. Create a decorator that hijacks a function, printing and returning
1. Create a decorator that takes a string and hijacks a function, printing the string and returning the string
1. Create a decorator that prints a string before the execution of the original function
1. Create a decorator that takes a string and prints the string before and after the execution of the original function
1. Create a decorator that takes a function as an argument, calls the function before and after the execution of the original function
1. Create a decorator that takes a function f and returns f(val) where val is the output of the original function
1. Create a class that acts like a decorator (see also callable objects)



# Closures
# Creating context managers
# Packaging and distribution of Python packages
# Callable objects, lambdas, and extended argument syntax
# Properties, class methods, and static methods
# String representations of objects
# Specialized numeric and scalar types
# Functional-style programming tools
# The iteration and iterable protocols
# Multiple inheritance, method resolution order, and super()
# Collection protocols and implementing collections
# Advanced error handling with exceptions
# Introspection
